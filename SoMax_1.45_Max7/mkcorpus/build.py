import os
import argparse
import logging
import settings
import ast
import re
from CorpusBuilder import CorpusBuilder
from melodic_from_json import MelJsonGenerator


class Main:
    """ New build script. Designed without support for interactive mode"""

    def __init__(self, input_path, output_folder, is_verbose, foreground, self_bg, mel_bg, harm_bg, uses_mel_from_json,
                 uses_held_melodics):
        self.logger = Main.init_logger(is_verbose)

        if not os.path.isabs(input_path):
            input_path = os.path.normpath(os.getcwd() + '/' + input_path)

        self.logger.debug('Script was initialized with the following parameters:\n'
                          + settings.DEBUG_INDENT + 'Input file/folder: {0}\n'.format(input_path)
                          + settings.DEBUG_INDENT + 'Output folder: {0}\n'.format(output_folder)
                          + settings.DEBUG_INDENT + 'Foreground channel(s): {0}\n'.format(foreground)
                          + settings.DEBUG_INDENT + 'Self Background channel(s): {0}\n'.format(self_bg)
                          + settings.DEBUG_INDENT + 'Melodic Background channel(s): {0}\n'.format(mel_bg)
                          + settings.DEBUG_INDENT + 'Harmonic Background channel(s): {0}\n'.format(harm_bg))
        # TODO: Improve this: Currently only checks if folder is named 'corpus', insufficient verification
        if os.path.normpath(os.path.basename(output_folder)) != settings.CORPUS_FOLDER_NAME:
            self.logger.warn('Output folder is not set to default and will likely not be available inside SoMax, '
                             'is this intentional?\n'
                             'To ensure correct behaviour, please either run the script directly inside\n'
                             'the folder SoMax/corpus or use the -o option to point to this directory.')

        builder = CorpusBuilder(input_path, foreground_channels=foreground, self_bg_channels=self_bg,
                                mel_bg_channels=mel_bg, harm_bg_channels=harm_bg)

        # Build the corpus and write all the files
        output_filepaths = builder.build_corpus(os.path.normpath(output_folder) + '/')
        log_string = "The following files were written:"
        for fp in output_filepaths:
            log_string += '\n' + settings.INFO_INDENT + fp
        self.logger.info(log_string)

        # TODO: Note that this overwrites the melodic json generated by builder. Fix Conflicting behaviour
        if uses_mel_from_json:
            self.generate_mel_from_json(output_filepaths, uses_held_melodics)

    def generate_mel_from_json(self, output_filepaths, uses_held_melodics):
        """ # TODO: Proper docstring
            Note that this assumes that the first json file written will always be the standard file """
        self.logger.debug('Writing melodic json using melodic_from_json with the following parameters:\n'
                          + settings.DEBUG_INDENT + 'Input file: {}\n'.format(output_filepaths[0])
                          + settings.DEBUG_INDENT + 'Held: {}\n'.format(uses_held_melodics))
        MelJsonGenerator.generate_mel_json(output_filepaths[0], uses_held_melodics)

    @staticmethod
    def path_if_valid(path):
        if os.path.exists(path):
            return path
        else:
            raise argparse.ArgumentTypeError('"{0}" is not a valid path'.format(path))

    @staticmethod
    def is_midi_file_or_folder(path):
        Main.path_if_valid(path)
        _, file_ext = os.path.splitext(path)
        if file_ext in settings.MIDI_FILE:
            return path
        elif os.path.isdir(path):
            return path
        else:
            raise argparse.ArgumentTypeError('"{0}" is not a midi file or a valid folder.'.format(path))

    @staticmethod
    def is_folder(path):
        Main.path_if_valid(path)
        if os.path.isdir(path):
            return path
        else:
            raise argparse.ArgumentTypeError('"{0}" is not a directory file.'.format(path))

    @staticmethod
    def init_logger(is_verbose):
        # TODO: Format logger properly
        logger = logging.getLogger(settings.MAIN_LOGGER)
        ch = logging.StreamHandler()
        if is_verbose:
            logger.setLevel(logging.DEBUG)
            ch.setLevel(logging.DEBUG)  # Set output logging level, needs to be set twice (?)
        else:
            logger.setLevel(logging.INFO)
            ch.setLevel(logging.INFO)
        formatter = logging.Formatter('[%(levelname)s]: %(message)s')
        ch.setFormatter(formatter)
        logger.addHandler(ch)
        return logger

    @staticmethod
    def parse_list(arg_name, list_as_string):
        """ Note: Parsing brackets from command line is fairly complicated, this function will hence attempt to parse
                  it as a tuple. # TODO: Proper docstring"""
        try:
            maybe_list = ast.literal_eval(list_as_string)
            if isinstance(maybe_list, tuple) and all([isinstance(v, int) for v in maybe_list]):
                return list(maybe_list)
            elif isinstance(maybe_list, int):
                return [maybe_list]
            else:
                Main.throw_list_parse_error(arg_name, list_as_string)
        except (SyntaxError, ValueError) as e:
            Main.throw_list_parse_error(arg_name, list_as_string)

    @staticmethod
    def throw_list_parse_error(arg_name, list_as_string):
        raise argparse.ArgumentTypeError('Error while parsing "{0}": formatting should only be a list of '
                                         'integers without spaces.\n '
                                         'Example: 1,2,3,6\n'
                                         'Your input was: {1}.'.format(arg_name, list_as_string))

    @staticmethod
    def parse_fg(list_as_string):
        return Main.parse_list("Foreground", list_as_string)

    @staticmethod
    def parse_sbg(list_as_string):
        return Main.parse_list("Self Background", list_as_string)

    @staticmethod
    def parse_mbg(list_as_string):
        return Main.parse_list("Melodic Background", list_as_string)

    @staticmethod
    def parse_hbg(list_as_string):
        return Main.parse_list("Harmonic Background", list_as_string)


if __name__ == '__main__':
    # TODO: Handle legacy input arguments -i in a meaningful way
    parser = argparse.ArgumentParser()
    parser.add_argument("inputfile", help="Path to the midi file or folder to parse", type=Main.is_midi_file_or_folder)
    parser.add_argument("-o", "--output_folder", help="Path to the corpus folder", type=Main.is_folder,
                        default=settings.DEFAULT_CORPUS_PATH)
    parser.add_argument("-v", "--verbose", help="Verbose output", action='store_true', default=False)
    parser.add_argument("-f", "--foreground",
                        help="Specify which midi channel(s) that will be used as foreground"
                             "(output) by Somax. Channels must be specified as a comma separated"
                             "list without spaces.\n"
                             "EXAMPLE: 1,2,8 will result in channels 1, 2 and 8 as output channels.",
                        type=Main.parse_fg, default=settings.DEFAULT_FOREGROUND)
    parser.add_argument("-sb", "--self_bg",
                        help="Specify which midi channel(s) Somax will listen to when mode is set to SELF.\n"
                             "Formatting: see --foreground",
                        type=Main.parse_sbg, default=settings.DEFAULT_SELF_BACKGROUND)
    parser.add_argument("-mb", "--mel_bg",
                        help="Specify which midi channel(s) Somax will listen to when mode is set to MELODIC.\n"
                             "Formatting: see --foreground",
                        type=Main.parse_mbg, default=settings.DEFAULT_MEL_BACKGROUND)
    parser.add_argument("-hb", "--harm_bg",
                        help="Specify which midi channel(s) Somax will listen to when mode is set to HARMONIC.\n"
                             "Formatting: see --foreground",
                        type=Main.parse_hbg, default=settings.DEFAULT_HARM_BACKGROUND)
    # TODO: Note that this is conflicting with mel_bg - a better solution is required
    parser.add_argument("--melodic-from-json",
                        help="Generates melodic file from the generated json using the melodic_from_json script, "
                             "overwriting defined behaviour above.", action='store_true', default=False)
    # TODO: Proper help string
    parser.add_argument("--melodic-are-held",
                        help="Optional argument for --melodic-from-json. Recommended to use when --melodic-from-json is"
                             "set.", action='store_true', default=False)

    args = parser.parse_args()

    Main(args.inputfile, args.output_folder, args.verbose, args.foreground, args.self_bg, args.mel_bg, args.harm_bg,
         args.melodic_from_json, args.melodic_are_held)
